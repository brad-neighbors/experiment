package com.incandescent.lean.experiment.db.relational.jdbc;

import com.incandescent.lean.experiment.ABExperiment;
import com.incandescent.lean.experiment.Experiment;
import com.incandescent.lean.experiment.ExperimentName;
import com.incandescent.lean.experiment.MultiOutcomeExperiment;
import com.incandescent.lean.experiment.Option;
import com.incandescent.lean.experiment.Subject;
import com.incandescent.lean.experiment.db.ExperimentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.PreparedStatementSetter;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.incandescent.lean.experiment.db.relational.jdbc.ExperimentReflectionUtils.*;
import static com.incandescent.lean.experiment.db.relational.jdbc.OptionReflectionUtils.*;
import static com.incandescent.lean.experiment.db.relational.jdbc.SubjectReflectionUtils.setSubjectField;
import static org.apache.commons.lang.Validate.notEmpty;

/**
 * Implements persisting experiments using the Spring JDBC template.
 * <p/>
 * This approach relies heavily on reflection in order to keep the domain model nicely encapsulated and
 * not require exposing data via accessors.
 *
 * @author Brad Neighbors
 */
@Repository
public class JdbcExperimentRepository implements ExperimentRepository {

    private JdbcTemplate jdbcTemplate;

    @Autowired
    public JdbcExperimentRepository(DataSource dataSource) {
        jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Override
    public void store(final Experiment experimentToPersist) {
        final Experiment existingExperiment = findExperimentBy(experimentToPersist.getName());
        if (existingExperiment != null) {
            handleUpdate(existingExperiment, experimentToPersist);
        } else {
            handleInsert(experimentToPersist);
        }
    }

    private void handleInsert(final Experiment experiment) {
        KeyHolder experimentKeyHolder = new GeneratedKeyHolder();
        jdbcTemplate.update(new PreparedStatementCreator() {
            @Override
            public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
                PreparedStatement ps = con.prepareCall("INSERT INTO experiment(experiment_name, class_name, date_started, date_ended) VALUES (?, ?, ?, ?)");
                ps.setString(1, experiment.getName().val());
                ps.setString(2, experiment.getClass().getSimpleName());
                ps.setDate(3, experiment.startedOn() != null ? new java.sql.Date(experiment.startedOn().getTime()) : null);
                ps.setDate(4, experiment.endedOn() != null ? new java.sql.Date(experiment.endedOn().getTime()) : null);
                return ps;
            }
        }, experimentKeyHolder);

        // set the ID auto generated by the database
        final Integer experimentId = experimentKeyHolder.getKey().intValue();
        setExperimentField(experiment, "id", experimentId);

        // persist each option
        final Set<Option> options = getOptions(experiment);
        for (final Option eachOption : options) {
            insertOption(eachOption, experiment);
        }

        // persist each subject outcome
        final Map<Subject, Option> subjectOutcomes = getOutcomes(experiment);
        for (final Subject eachSubject : subjectOutcomes.keySet()) {
            insertSubject(eachSubject, experiment);
        }
    }

    private void insertSubject(final Subject eachSubject, final Experiment experiment) {
        Map<Subject, Option> subjectOutcomes = getOutcomes(experiment);
        final Integer optionId = getOptionId(subjectOutcomes.get(eachSubject));
        KeyHolder subjectKeyHolder = new GeneratedKeyHolder();
        jdbcTemplate.update(new PreparedStatementCreator() {
            @Override
            public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
                PreparedStatement ps = con.prepareCall("INSERT INTO subject_outcome (subject, option_id) VALUES (?, ?)");
                ps.setString(1, eachSubject.val());
                ps.setInt(2, optionId);
                return ps;
            }
        }, subjectKeyHolder);

        setSubjectField(eachSubject, "id", subjectKeyHolder.getKey().intValue());
        setSubjectField(eachSubject, "optionId", optionId);
    }

    private void insertOption(final Option option, final Experiment experiment) {
        final Map<Option, Integer> outcomeCounts = getOutcomeCounts(experiment);
        final Integer experimentId = getExperimentId(experiment);
        KeyHolder optionKeyHolder = new GeneratedKeyHolder();
        jdbcTemplate.update(new PreparedStatementCreator() {
            @Override
            public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
                PreparedStatement ps = con.prepareCall("INSERT INTO experiment_option (experiment_id, option_name, outcome_count, option_sequence) VALUES (?, ?, ?, ?)");
                ps.setInt(1, experimentId);
                ps.setString(2, option.val());
                ps.setInt(3, outcomeCounts.get(option) != null ? outcomeCounts.get(option) : 0);
                ps.setInt(4, getOptionSequence(option));
                return ps;
            }
        }, optionKeyHolder);

        setOptionField(option, "id", optionKeyHolder.getKey().intValue());
        setOptionField(option, "experimentId", experimentId);
    }

    private void handleUpdate(final Experiment existingExperiment, final Experiment experimentToPersist) {
        jdbcTemplate.update("UPDATE experiment SET date_started = ?, date_ended = ? WHERE experiment_name = ?",
          new PreparedStatementSetter() {
              @Override
              public void setValues(PreparedStatement ps) throws SQLException {
                  ps.setDate(1, experimentToPersist.startedOn() != null ? new java.sql.Date(experimentToPersist.startedOn().getTime()) : null);
                  ps.setDate(2, experimentToPersist.endedOn() != null ? new java.sql.Date(experimentToPersist.endedOn().getTime()) : null);
                  ps.setString(3, existingExperiment.getName().val());
              }
          });

        final Set<Option> existingOptions = getOptions(existingExperiment);
        final Set<Option> changedOptions = getOptions(experimentToPersist);
        for (Option eachChangedOption : changedOptions) {
            if (existingOptions.contains(eachChangedOption)) {
                updateOption(eachChangedOption, experimentToPersist);
            } else {
                insertOption(eachChangedOption, experimentToPersist);
            }
        }

        final Map<Subject, Option> existingOutcomes = getOutcomes(existingExperiment);
        final Map<Subject, Option> changedOutcomes = getOutcomes(experimentToPersist);
        for (final Subject eachSubject : changedOutcomes.keySet()) {
            if (existingOutcomes.containsKey(eachSubject)) {
                // update
                final Integer optionId = getOptionId(changedOutcomes.get(eachSubject));
                updateSubjectOutcome(eachSubject, optionId);
            } else {
                // insert
                insertSubject(eachSubject, experimentToPersist);
            }
        }
    }

    private void updateSubjectOutcome(final Subject eachSubject, final Integer optionId) {
        jdbcTemplate.update("UPDATE subject_outcome SET option_id = ? WHERE subject = ?",
          new PreparedStatementSetter() {
              @Override
              public void setValues(PreparedStatement ps) throws SQLException {
                  ps.setInt(1, optionId);
                  ps.setString(2, eachSubject.val());
              }
          });
    }

    private void updateOption(final Option option, final Experiment experiment) {
        final Integer outcomeCount = getOutcomeCounts(experiment).get(option);
        final Integer optionId = getOptionId(option);
        jdbcTemplate.update("UPDATE experiment_option SET outcome_count = ? WHERE id = ?", new PreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps) throws SQLException {
                ps.setInt(1, outcomeCount != null ? outcomeCount : 0);
                ps.setInt(2, optionId);
            }
        });
    }

    @Override
    public Experiment findExperimentBy(ExperimentName name) {
        String sql =
          "SELECT e.id as experiment_id, " +
            "     e.experiment_name, " +
            "     e.class_name, " +
            "     e.date_started, " +
            "     e.date_ended, " +
            "     o.id as option_id, " +
            "     o.option_name, " +
            "     o.outcome_count, " +
            "     o.option_sequence, " +
            "     so.id as subject_outcome_id, " +
            "     so.option_id, " +
            "     so.subject " +
            "FROM experiment e " +
            "LEFT OUTER JOIN experiment_option o ON o.experiment_id = e.id " +
            "LEFT OUTER JOIN subject_outcome so ON so.option_id = o.id " +
            "WHERE e.experiment_name = '" + name + "' " +
            "ORDER BY e.id, o.option_sequence, so.id";

        final List<Experiment> experiments = jdbcTemplate.query(sql, new ExperimentResultSetExtractor());
        return experiments.isEmpty() ? null : experiments.get(0);
    }

    @Override
    public List<ExperimentName> findExperimentNamesBy(String searchTerm) {
        notEmpty(searchTerm, "Argument searchTerm cannot be empty");
        if (searchTerm.length() < ExperimentName.MINIMUM_LENGTH) {
            return new ArrayList<ExperimentName>();
        }
        final String sql =
          "SELECT e.experiment_name " +
            "FROM experiment e " +
            "WHERE e.experiment_name LIKE '" + searchTerm + "%' " +
            "ORDER BY e.experiment_name";

        return jdbcTemplate.query(sql, new ResultSetExtractor<List<ExperimentName>>() {
            @Override
            public List<ExperimentName> extractData(ResultSet rs) throws SQLException, DataAccessException {
                final List<ExperimentName> names = new ArrayList<ExperimentName>();
                while (rs.next()) {
                    names.add(new ExperimentName(rs.getString("experiment_name")));
                }
                return names;
            }
        });
    }

    @Override
    public MultiOutcomeExperiment findMultiOutcomeExperimentBy(ExperimentName name) {
        final Experiment experiment = findExperimentBy(name);
        if (experiment != null) {
            return experiment.getClass().isAssignableFrom(MultiOutcomeExperiment.class) ? (MultiOutcomeExperiment) experiment : null;
        }
        return null;
    }

    @Override
    public ABExperiment findAorBExperimentBy(ExperimentName name) {
        final Experiment experiment = findExperimentBy(name);
        if (experiment != null) {
            return experiment.getClass().isAssignableFrom(ABExperiment.class) ? (ABExperiment) experiment : null;
        }
        return null;
    }

    private static class ExperimentResultSetExtractor implements ResultSetExtractor<List<Experiment>> {

        @Override
        public List<Experiment> extractData(ResultSet rs) throws SQLException, DataAccessException {
            final Map<String, Experiment> experiments = new HashMap<String, Experiment>();
            while (rs.next()) {

                final Integer experimentId = rs.getInt("experiment_id");
                final String experimentNameStr = rs.getString("experiment_name");
                final String className = rs.getString("class_name");
                final Date dateStarted = rs.getDate("date_started");
                final Date dateEnded = rs.getDate("date_ended");

                Experiment experiment = null;
                if (experiments.containsKey(experimentNameStr)) {
                    // already found this experiment in the result set
                    experiment = experiments.get(experimentNameStr);
                } else {
                    // new experiment in the result set
                    if (MultiOutcomeExperiment.class.getSimpleName().equals(className)) {
                        experiment = new MultiOutcomeExperiment(new ExperimentName(experimentNameStr));
                        setExperimentField(experiment, "dateStarted", dateStarted);
                        setExperimentField(experiment, "dateEnded", dateEnded);
                        setExperimentField(experiment, "id", experimentId);
                        experiments.put(experimentNameStr, experiment);

                    } else if (ABExperiment.class.getSimpleName().equals(className)) {
                        experiment = new ABExperiment(new ExperimentName(experimentNameStr));
                        setExperimentField(experiment, "dateStarted", dateStarted);
                        setExperimentField(experiment, "dateEnded", dateEnded);
                        setExperimentField(experiment, "id", experimentId);
                        experiments.put(experimentNameStr, experiment);
                    }
                }

                final Map<String, Option> options = new HashMap<String, Option>();
                final String optionNameStr = rs.getString("option_name");
                final Integer optionId = rs.getInt("option_id");
                final Integer optionSequence = rs.getInt("option_sequence");
                if (optionNameStr != null) {
                    Option option = null;
                    if (options.containsKey(optionNameStr)) {
                        // already found this option in the result set
                        option = options.get(optionNameStr);
                    } else {
                        option = new Option(optionNameStr);
                        setOptionField(option, "id", optionId);
                        setOptionField(option, "sequence", optionSequence);
                        setOptionField(option, "experimentId", experimentId);
                        options.put(optionNameStr, option);
                    }
                    final Set<Option> options1 = getOptions(experiment);
                    options1.add(option);
                    final Map<Option, Integer> outcomeCounts = getOutcomeCounts(experiment);
                    outcomeCounts.put(option, rs.getInt("outcome_count"));

                    final String subjectStr = rs.getString("subject");
                    final Integer subjectId = rs.getInt("subject_outcome_id");
                    if (subjectStr != null) {
                        final Map<Subject, Option> outcomes = getOutcomes(experiment);
                        final Subject newSubject = new Subject(subjectStr);
                        setSubjectField(newSubject, "id", subjectId);
                        outcomes.put(newSubject, option);
                    }
                }

            }
            return new ArrayList<Experiment>(experiments.values());
        }
    }

}
